---
title: Vorlesungsnotizen zum 17.04.2018
layout: post
categories: cc2018-lecturenotes
---

# Vorlesungsnotizen zum 17.04.2018

## Tooling
Zu Beginn des Seminars sollen euch die notwendigen Werkzeuge zur Lösung der bevorstehenden Aufgaben angereicht werden.

### Komplexitätstheorie, kurz gefasst
* O-Notation, Durchzählen beim Bruteforce Beispiel
  * Woran erkenne ich, das mein Ansatz zu langsam ist?
  * Schleife kann noch so schnell sein, wenn n groß
* Wie schnell ist mein Programm?
  * Zeitmessung mit time
  * Advanced Zeitmessung mit python
* Wie visualisiere ich das?
  * Ausgaben in csv
  * Plotten mit **gnuplot**

### Problemlösungsstrategien
* Ressourcen aufzeigen:
  * OEIS
* Level bestimmen


## Eine Brute Force Lösung
``` c++
#include <cstdint>
#include <iostream>
#include <gmp.h>
#include <gmpxx.h>

int main(){
 mpz_class input;
 cin << input;
 
 mpz_class line = 0;
 mpz_class linesize = 1;
 mpz_class i = 0;
 while(i < input){
  i += linesize;
  line++;
  linesize += 2;
 }
 
 mpz_class line_middle = line*line - line + 1;
 mpz_class column = input - line_middle;
 column = abs(column);
 line--;
 mpz_class result = line+column;
 cout << result << endl;
 return 0;
}

```

Woran erkennt man, dass diese Lösung nicht weit hilft? Messen:
* Debug by echo
* Intern Zeit messen
* Extern Zeit messen
* Manuelle Komplexitätsanalyse
* Praktische Komplexitätsanalyse

### Ein Gefühl für Zeit (Debug by echo)

Fügen wir mal folgende Ausgabe in die Schleife ein:

``` c++
 while(i < input){
  i += linesize;
  line++;
  linesize += 2;
  cout << i << endl;
 }
 ```

Beobachten Sie, wie schnell der untersuchte Raum anwächst. 

Ab einigen Dezimalstellen wird es deutlich langsamer. Die erste Drosselung erlebt man vielleicht ab der aktuell üblichen Maschinenwortgrenze (32/64 Bit). Aber bald sollte auffallen, dass dieser Suchansatz ab einer bestimmten Größe "verhungert". Bestimmte die Differenz an Dezimalstellen zwischen dem in einer Minute erreichten Zahlenraum mit der Eingabezahl.

### Interne Zeitmessung

C++11 erlaubt folgende Zeitmessungshilfen:

``` c++
std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
// [Zu messender Code hier]
std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
auto duration_in_us = std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count();
```

Testen Sie ihren Code mit mehreren Testeingaben unterschiedlicher Größe und vergleichen Sie den Zuwachs.

Vorteil(e):
* Messpunkte sehr genau einstellbar.
Nachteile:
* Eingriff in das zu testende Objekt notwendig. Messen kann das Verhalten des Programms beeinflussen.

### Externe Zeitmessung

Von außen betrachtet haben wir natürlich alle Möglichkeiten, die uns unser Betriebssystem so anbieten, Messungen vorzunehmen. Im Folgenden habe ich hier ein Beispiel, was uns gleich die Messung in einem angenehmen Format aufarbeitet:

``` python
#!/usr/bin/env python3

import subprocess
import time
import random
import sys

from subprocess import *

uut = sys.argv[1]

for i in range(1,128,1):
    proc_uut = subprocess.Popen([uut], stdin=PIPE, stdout=PIPE)
    # Eine zufällige Eingabe erzeugen
    input = str(random.randint(10**i, 10**(i+1))) + "\n"

    before = time.monotonic()
    out_uut = proc_uut.communicate(input.encode(), timeout=60)[0].decode()
    after = time.monotonic()
    time_uut = after-before

    print("{};{}".format(i, time_uut))

```

Dieses Testprogramm lässt das Programm in einer Schleife zufällige Eingabezahlen abarbeiten, nimmt die Zeit ab und dokumentiert sie im CSV Format. Das hilft uns wesentlich für eine spätere Visualisierung.

Vorteil(e):
* Besser automatisierbar
* Auch direkte Vergleiche mit Lösungen und anderen Programmen möglich 
* Entkoppelt vom eigentlich zu testendem Programm
Nachteile:
* Nicht so fein einstellbar in den Messpunkten. Diese sind hier fix: Direkt vor Lesen der Eingabe und direkt nach Empfangen der Ausgabe. Hier sind lastbedingte oder betriebssystembedingte Schwankungen möglich.

### Manuelle Komplexitätsanalyse

tbd

### Praktische Komplexitätsanalyse

gprof

### etc
> Vielleicht kann ich an der Schleife noch etwas optimieren.

Das ist eine wichtige im Praktikum gehörte Frage und dazu möchte ich folgenden Denkanstoß liefern:

Die Addition ist mit eine der (in Bezug auf Zeitkomplexität) leichtesten Operationen, die wir in Algorithmen einsetzen können. Entscheidend in unserer Beispielaufgabe ist die Häufigkeit der Aufrufe.

